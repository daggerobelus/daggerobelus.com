<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Healer's Trap: Folk Medicine and Witch Accusations</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Libre+Franklin:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Theme Variables */
        :root {
            /* Typography */
            --font-heading: 'Libre Baskerville', Georgia, serif;
            --font-body: 'Libre Franklin', system-ui, sans-serif;
            --font-ui: 'Libre Franklin', system-ui, sans-serif;

            /* Site theme colors */
            --color-cream: #fff7f4;
            --color-ink: #121212;
            --color-link: #009FDA;
            --color-accent: #009FDA;

            /* Derived colors for UI */
            --color-bg: var(--color-cream);
            --color-bg-subtle: #f5efe9;
            --color-bg-card: #ffffff;
            --color-border: rgba(18, 18, 18, 0.1);
            --color-border-strong: rgba(18, 18, 18, 0.2);
            --color-text: var(--color-ink);
            --color-text-muted: rgba(18, 18, 18, 0.6);
            --color-text-subtle: rgba(18, 18, 18, 0.4);
            --color-text-light: rgba(255, 255, 255, 0.95);
            --color-text-light-muted: rgba(255, 255, 255, 0.7);

            /* Data visualization colors */
            --color-death: #c0392b;
            --color-released: #27ae60;
            --color-banished: #d4a017;
            --color-fled: #2980b9;
            --color-unknown: #7f8c8d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-heading);
        }

        .dashboard {
            display: grid;
            grid-template-columns: 280px 1fr;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
        }

        /* Header */
        header {
            grid-column: 1 / -1;
            background: var(--color-bg-card);
            padding: 25px 30px;
            border-bottom: 1px solid var(--color-border);
        }

        header h1 {
            font-size: 1.8em;
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        header .subtitle {
            color: var(--color-text-muted);
            font-size: 1em;
        }

        /* Header Navigation */
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-nav {
            display: flex;
            gap: 8px;
        }

        .header-nav a {
            color: var(--color-text-muted);
            text-decoration: none;
            font-size: 0.85em;
            padding: 8px 14px;
            border-radius: 20px;
            background: var(--color-bg-subtle);
            border: 1px solid var(--color-border);
            transition: all 0.2s;
        }

        .header-nav a:hover {
            background: var(--color-border-strong);
            color: var(--color-text);
        }

        .header-nav a.active {
            background: var(--color-accent);
            border-color: var(--color-accent);
            color: #fff;
        }

        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Scroll margin for sections */
        .section-anchor {
            scroll-margin-top: 100px;
        }

        /* Sidebar */
        .sidebar {
            background: var(--color-bg-subtle);
            padding: 20px;
            border-right: 1px solid var(--color-border);
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
        }

        .filter-section {
            margin-bottom: 18px;
        }

        .filter-section h3 {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--color-text-muted);
            margin-bottom: 12px;
            font-family: var(--font-ui);
        }

        .filter-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .filter-btn {
            padding: 3px 6px;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            color: var(--color-text-subtle);
            font-size: 0.8em;
            font-weight: 600;
            font-family: var(--font-ui);
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: var(--color-border-strong);
            color: var(--color-text);
        }

        .filter-btn.active {
            background: var(--color-accent);
            border-color: var(--color-accent);
            color: #fff;
        }

        .stat-card-mini {
            padding: 12px 0;
            margin-bottom: 10px;
        }

        .stat-card-mini .label {
            font-size: 0.8em;
            color: var(--color-text-muted);
        }

        .stat-card-mini .value {
            font-size: 1.4em;
            font-weight: 600;
            color: var(--color-text);
        }

        /* Main Content */
        .main-content {
            padding: 25px;
            padding-bottom: 5rem;
            overflow-y: auto;
            background: var(--color-bg);
        }

        /* Stat Cards Row */
        .stat-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 2em;
            padding-bottom: 20px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--color-border);
        }

        .stat-card {
            padding: 10px 0;
        }

        .stat-card .label {
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-muted);
            margin-bottom: 8px;
            font-family: var(--font-ui);
        }

        .stat-card .value {
            font-size: 2.2em;
            font-weight: 700;
            color: var(--color-text);
        }

        .stat-card .subtext {
            font-size: 0.85em;
            color: var(--color-text-subtle);
            margin-top: 5px;
        }

        .stat-card .subtext.baseline-compare {
            color: var(--color-text-muted);
            font-style: italic;
            margin-top: 8px;
        }

        .stat-card.highlight {
            /* highlight through color only, no box */
        }

        .stat-card.highlight .value {
            color: var(--color-accent);
        }

        /* Types Overview */
        .types-overview {
            margin-bottom: 40px;
        }

        .types-overview .intro-text {
            color: var(--color-text-muted);
            font-size: 1em;
            margin-bottom: 24px;
            line-height: 1.7;
            max-width: 75ch;
        }

        .type-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            overflow: visible;
        }

        .type-card {
            background: var(--color-bg-card);
            border-radius: 10px;
            padding: 22px;
            border: 1px solid var(--color-border);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .type-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 50;
        }

        .type-card .card-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            width: 280px;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border-strong);
            border-radius: 8px;
            padding: 15px;
            font-size: 0.85em;
            line-height: 1.5;
            color: var(--color-text);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1000;
            pointer-events: auto;
            margin-top: 10px;
        }

        .type-card .card-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 20px;
            border: 8px solid transparent;
            border-bottom-color: var(--color-border-strong);
        }

        /* Right-aligned tooltip for cards on the right side */
        .type-card.tooltip-right .card-tooltip {
            left: auto;
            right: 0;
        }

        .type-card.tooltip-right .card-tooltip::before {
            left: auto;
            right: 20px;
        }

        .type-card:hover .card-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .type-card .card-tooltip strong {
            color: var(--color-accent);
        }

        .type-card .card-tooltip .tooltip-quote {
            font-size: 1.1em;
            font-style: italic;
            color: var(--color-accent);
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-border);
            line-height: 1.4;
        }

        .type-card .card-tooltip .tooltip-narrative {
            font-size: 0.9em;
            color: var(--color-text-muted);
        }

        .type-card .card-tooltip .tooltip-citation {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
            font-size: 0.85em;
            color: var(--color-accent);
            cursor: pointer;
            transition: color 0.2s;
        }

        .type-card .card-tooltip .tooltip-citation:hover {
            color: var(--color-link);
            text-decoration: underline;
        }

        .type-card.selected {
            border-color: var(--color-accent);
            box-shadow: 0 0 0 2px var(--color-accent), 0 4px 15px rgba(0, 159, 218, 0.2);
        }

        .type-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 14px;
        }

        .type-card-header .type-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .type-card-header .type-name {
            font-size: 1em;
            font-weight: 600;
            color: var(--color-text);
        }

        .type-card-header .type-count {
            margin-left: auto;
            font-size: 0.85em;
            color: var(--color-text-muted);
            background: var(--color-bg-subtle);
            padding: 3px 10px;
            border-radius: 12px;
            font-family: var(--font-ui);
        }

        .type-card-desc {
            font-size: 0.85em;
            color: var(--color-text-muted);
            line-height: 1.6;
            margin-bottom: 14px;
            min-height: 42px;
        }

        .type-card-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .type-card-stat {
            background: var(--color-bg-subtle);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .type-card-stat .stat-value {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--color-text);
        }

        .type-card-stat .stat-value.high-death {
            color: var(--color-death);
        }

        .type-card-stat .stat-label {
            font-size: 0.65em;
            color: var(--color-text-subtle);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: var(--font-ui);
        }

        .type-card-examples {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
            font-size: 0.75em;
            color: var(--color-text-subtle);
        }

        .type-card-examples strong {
            color: var(--color-text-muted);
        }

        /* Featured Quote Banner */
        .featured-quote {
            background: var(--color-bg-subtle);
            border: 1px solid var(--color-border);
            border-left: 4px solid var(--color-accent);
            border-radius: 8px;
            padding: 24px 28px;
            margin-bottom: 24px;
            position: relative;
            /* max-width: 75ch; -- TESTING: Full width */
        }

        .featured-quote-text {
            font-size: 1.1em;
            font-style: italic;
            color: var(--color-text);
            line-height: 1.7;
            margin-bottom: 12px;
        }

        .featured-quote-text::before {
            content: '"';
            font-size: 2em;
            color: var(--color-accent);
            position: absolute;
            left: 15px;
            top: 10px;
            opacity: 0.5;
        }

        .featured-quote-attribution {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .featured-quote-attribution .healer-name {
            font-weight: 600;
            color: var(--color-text);
        }

        .featured-quote-attribution .healer-link {
            cursor: pointer;
            transition: color 0.2s;
        }

        .featured-quote-attribution .healer-link:hover {
            color: var(--color-accent);
            text-decoration: underline;
        }

        .featured-quote-attribution .healer-type {
            font-size: 0.85em;
            color: var(--color-text-muted);
            padding: 3px 10px;
            background: var(--color-bg-card);
            border-radius: 12px;
            border: 1px solid var(--color-border);
        }

        .featured-quote-attribution .quote-context {
            font-size: 0.85em;
            color: var(--color-text-subtle);
            flex-basis: 100%;
            margin-top: 5px;
        }

        .featured-quote-nav {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 8px;
        }

        .featured-quote-nav button {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            color: var(--color-text-muted);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .featured-quote-nav button:hover {
            background: var(--color-border-strong);
            color: var(--color-text);
        }

        /* Section Headers */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--color-text);
            margin: 40px 0 20px 0;
            border-bottom: 1px solid var(--color-border);
        }

        .section-header input {
            padding: 10px 14px;
            background: var(--color-bg-subtle);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-size: 0.9rem;
            color: var(--color-text);
            font-family: var(--font-ui);
            margin-bottom: 8px;
        }

        .section-header input::placeholder {
            color: var(--color-text-muted);
        }

        .section-header .filter-context {
            color: var(--color-accent);
        }

        /* Active Filters Bar */
        .active-filters {
            background: rgba(0, 159, 218, 0.05);
            border: 1px solid var(--color-accent);
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .active-filters-label {
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-muted);
            margin-right: 5px;
            font-family: var(--font-ui);
        }

        .filter-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: 15px;
            padding: 5px 10px;
            font-size: 0.85em;
            color: var(--color-text);
        }

        .filter-tag .tag-label {
            color: var(--color-text-muted);
        }

        .filter-tag .tag-value {
            color: var(--color-text);
        }

        .filter-tag .tag-remove {
            background: none;
            border: none;
            color: var(--color-text-muted);
            cursor: pointer;
            font-size: 1.1em;
            line-height: 1;
            padding: 0;
            margin-left: 2px;
        }

        .filter-tag .tag-remove:hover {
            color: var(--color-accent);
        }

        .clear-all-filters {
            margin-left: auto;
            background: none;
            border: 1px solid var(--color-accent);
            color: var(--color-accent);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
            font-family: var(--font-ui);
        }

        .clear-all-filters:hover {
            background: var(--color-accent);
            color: #fff;
        }


        /* Outcomes Chart */
        .outcomes-chart {
            margin-bottom: 40px;
            overflow: visible;
        }

        .outcomes-bars {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            overflow: visible;
        }

        .outcome-item {
            flex: 1 0 auto;
            min-width: 120px;
            text-align: center;
        }

        .outcome-bar-container {
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 8px;
        }

        .outcome-bar {
            width: 75%;
            border-radius: 4px 4px 0 0;
            transition: height 0.5s ease;
            position: relative;
        }

        .outcome-bar.death { background: linear-gradient(180deg, #e74c3c, #c0392b); }
        .outcome-bar.released { background: linear-gradient(180deg, #2ecc71, #27ae60); }
        .outcome-bar.banished { background: linear-gradient(180deg, #f1c40f, #d4a017); }
        .outcome-bar.fled { background: linear-gradient(180deg, #3498db, #2980b9); }
        .outcome-bar.unknown { background: linear-gradient(180deg, #95a5a6, #7f8c8d); }

        .outcome-value {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--color-text);
            margin-bottom: 4px;
        }

        .outcome-label {
            font-size: 0.85em;
            color: var(--color-text-muted);
            text-transform: capitalize;
        }

        .outcome-count {
            font-size: 0.75em;
            color: var(--color-text-subtle);
            margin-top: 2px;
        }

        .outcome-item {
            position: relative;
            cursor: pointer;
        }

        .outcome-item:hover .outcome-bar {
            transform: scaleX(1.1);
        }

        .outcome-tooltip {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-bg-card);
            border: 1px solid var(--color-border-strong);
            border-radius: 8px;
            padding: 15px;
            width: 280px;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            text-align: left;
        }

        .outcome-item:hover .outcome-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .outcome-item:hover {
            z-index: 50;
        }

        .outcome-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-bottom-color: var(--color-border-strong);
        }

        /* Left-aligned tooltip for outcomes on the right side */
        .outcome-item.tooltip-right .outcome-tooltip {
            left: auto;
            right: 0;
            transform: none;
        }

        .outcome-item.tooltip-right .outcome-tooltip::after {
            left: auto;
            right: 20px;
            transform: none;
        }

        /* Right-aligned tooltip for outcomes on the left side */
        .outcome-item.tooltip-left .outcome-tooltip {
            left: 0;
            transform: none;
        }

        .outcome-item.tooltip-left .outcome-tooltip::after {
            left: 20px;
            transform: none;
        }

        .outcome-tooltip h4 {
            font-size: 1em;
            color: var(--color-text);
            margin-bottom: 10px;
        }

        .outcome-tooltip .tooltip-breakdown {
            font-size: 0.85em;
            color: var(--color-text-muted);
            margin-bottom: 10px;
        }

        .outcome-tooltip .tooltip-breakdown div {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid var(--color-border);
        }

        .outcome-tooltip .tooltip-examples {
            font-size: 0.8em;
            color: var(--color-text-muted);
            padding-top: 8px;
        }

        .outcome-tooltip .tooltip-examples strong {
            color: var(--color-text);
        }

        .outcome-tooltip .tooltip-quote {
            font-size: 1em;
            font-style: italic;
            color: var(--color-accent);
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-border);
            line-height: 1.4;
        }

        .outcome-tooltip .tooltip-narrative {
            font-size: 0.85em;
            color: var(--color-text-muted);
            line-height: 1.5;
        }

        .outcome-tooltip .tooltip-citation {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
            font-size: 0.85em;
            color: var(--color-accent);
            cursor: pointer;
            transition: color 0.2s;
        }

        .outcome-tooltip .tooltip-citation:hover {
            color: var(--color-link);
            text-decoration: underline;
        }

        /* Bar Chart Tooltips */
        .chart-bar {
            position: relative;
        }

        .chart-bar:hover {
            z-index: 50;
        }

        .bar-tooltip {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border-strong);
            border-radius: 8px;
            padding: 15px;
            width: 300px;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            text-align: left;
        }

        .chart-bar:hover .bar-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .bar-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 20px;
            border: 8px solid transparent;
            border-bottom-color: var(--color-border-strong);
        }

        .bar-tooltip .tooltip-quote {
            font-size: 1em;
            font-style: italic;
            color: var(--color-accent);
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-border);
            line-height: 1.4;
        }

        .bar-tooltip .tooltip-narrative {
            font-size: 0.85em;
            color: var(--color-text-muted);
            line-height: 1.5;
        }

        .bar-tooltip .tooltip-citation {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
            font-size: 0.85em;
            color: var(--color-accent);
            cursor: pointer;
            transition: color 0.2s;
        }

        .bar-tooltip .tooltip-citation:hover {
            color: var(--color-link);
            text-decoration: underline;
        }

        /* Charts Section */
        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .chart-card {
            padding: 20px 0;
            overflow: visible;
        }

        .chart-card h3 {
            font-size: 1em;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--color-text);
        }

        .chart-card.full-width {
            grid-column: 1 / -1;
        }

        /* Torture by Type Breakdown */
        .torture-type-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--color-border);
        }

        .torture-type-row:last-child {
            border-bottom: none;
        }

        .torture-type-label {
            width: 180px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: var(--color-text);
            flex-shrink: 0;
        }

        .torture-type-label .type-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .torture-type-count {
            color: var(--color-text-subtle);
            font-size: 0.85em;
        }

        .torture-comparison {
            flex: 1;
            display: flex;
            gap: 20px;
        }

        .torture-stat {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--color-bg-subtle);
            border-radius: 6px;
        }

        .torture-stat.tortured {
            border-left: 3px solid var(--color-death);
        }

        .torture-stat.not-tortured {
            border-left: 3px solid var(--color-released);
        }

        .torture-stat .torture-label {
            font-size: 0.8em;
            color: var(--color-text-muted);
            width: 80px;
        }

        .torture-stat .torture-rate {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--color-text);
            min-width: 45px;
        }

        .torture-stat .torture-rate.high {
            color: var(--color-death);
        }

        .torture-stat .torture-count {
            font-size: 0.75em;
            color: var(--color-text-subtle);
            margin-left: auto;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .chart-bar .bar-label {
            width: 100px;
            font-size: 0.85em;
            color: var(--color-text-muted);
            flex-shrink: 0;
        }

        .chart-bar .bar-track {
            flex: 1;
            height: 24px;
            background: var(--color-bg-subtle);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .chart-bar .bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .chart-bar .bar-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            font-weight: 600;
            color: var(--color-ink);
        }

        .chart-bar .bar-fill.bar-death-100 ~ .bar-value {
            color: var(--color-text-light);
        }

        .chart-bar .bar-count {
            width: 50px;
            text-align: right;
            font-size: 0.8em;
            color: var(--color-text-subtle);
            margin-left: 10px;
        }

        /* Color scales for bars */
        .bar-death-100 { background: linear-gradient(90deg, #c0392b, #e74c3c); }
        .bar-death-high { background: linear-gradient(90deg, #d35400, #e67e22); }
        .bar-death-mid { background: linear-gradient(90deg, #f39c12, #f1c40f); }
        .bar-death-low { background: linear-gradient(90deg, #27ae60, #2ecc71); }

        /* Baseline comparison indicator */
        .baseline-marker {
            display: none;
        }

        .chart-baseline-legend {
            display: none;
        }

        .baseline-legend-marker {
            width: 12px;
            height: 12px;
            background: var(--color-ink);
            border-radius: 50%;
            opacity: 0.7;
        }

        .comparison-note {
            font-size: 0.8em;
            color: var(--color-text-muted);
            margin-top: 8px;
            font-style: italic;
        }

        .comparison-note.better { color: var(--color-released); }
        .comparison-note.worse { color: var(--color-death); }
        .comparison-note.similar { color: var(--color-text-muted); }

        /* Trial Section */
        .trial-section {
            margin-bottom: 40px;
        }

        .trial-intro {
            color: var(--color-text-muted);
            font-size: 1em;
            margin-bottom: 24px;
            line-height: 1.7;
            max-width: 75ch;
        }

        .trial-intro .highlight {
            color: var(--color-accent);
            font-weight: 600;
        }

        .trial-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 40px;
        }

        .trial-stat {
            padding: 15px 10px;
            text-align: center;
        }

        .trial-stat .stat-value {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--color-text);
        }

        .trial-stat .stat-label {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-muted);
            margin-top: 4px;
            font-family: var(--font-ui);
        }

        .trial-stat .stat-context {
            font-size: 0.8em;
            color: var(--color-text-subtle);
            margin-top: 6px;
            font-style: italic;
        }

        .trial-stat.highlight-red .stat-value {
            color: var(--color-death);
        }

        .trial-stat.highlight-yellow .stat-value {
            color: var(--color-banished);
        }

        .trial-stat.highlight-green .stat-value {
            color: var(--color-released);
        }

        /* Accusation type badges */
        .accusation-bar {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px 12px;
            background: var(--color-bg-subtle);
            border-radius: 0 6px 6px 0;
            border-left: 4px solid;
        }

        .accusation-bar.harm-death { border-left-color: #e74c3c; }
        .accusation-bar.harm-illness { border-left-color: #e67e22; }
        .accusation-bar.harm-animal { border-left-color: #8e44ad; }
        .accusation-bar.harm-property { border-left-color: #3498db; }
        .accusation-bar.harm-other { border-left-color: #95a5a6; }

        .accusation-bar .accusation-label {
            flex: 1;
            font-size: 0.9em;
            color: var(--color-text);
        }

        .accusation-bar .accusation-count {
            font-size: 0.85em;
            color: var(--color-text-muted);
            margin-left: 10px;
        }

        .accusation-bar .accusation-bar-fill {
            width: 80px;
            height: 6px;
            background: var(--color-border-strong);
            border-radius: 3px;
            margin-left: 10px;
            overflow: hidden;
        }

        .accusation-bar .accusation-bar-fill span {
            display: block;
            height: 100%;
            border-radius: 3px;
        }

        /* Case building stats */
        .case-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--color-border);
        }

        .case-stat-row:last-child {
            border-bottom: none;
        }

        .case-stat-label {
            font-size: 0.9em;
            color: var(--color-text-muted);
        }

        .case-stat-value {
            font-size: 1em;
            font-weight: 600;
            color: var(--color-text);
        }

        /* Confession content */
        .confession-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 6px;
            background: var(--color-bg-subtle);
            border-radius: 6px;
        }

        .confession-item .confession-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .confession-item .confession-icon.active {
            background: var(--color-banished);
            color: #000;
        }

        .confession-item .confession-icon.inactive {
            background: var(--color-border-strong);
            color: var(--color-text-subtle);
        }

        .confession-item .confession-label {
            flex: 1;
            font-size: 0.9em;
            color: var(--color-text);
        }

        .confession-item .confession-rate {
            font-size: 0.9em;
            font-weight: 600;
            color: var(--color-banished);
            min-width: 40px;
        }

        .confession-item .confession-count {
            font-size: 0.75em;
            color: var(--color-text-subtle);
            margin-left: 8px;
        }

        /* Table Section */
        .table-section {
            overflow: hidden;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--color-border);
        }

        .table-header h3 {
            font-size: 1em;
            font-weight: 600;
        }

        .table-search {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-search input {
            padding: 8px 12px;
            background: var(--color-bg-subtle);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            color: var(--color-text);
            font-size: 0.9em;
            width: 200px;
            font-family: inherit;
        }

        .table-search input::placeholder {
            color: var(--color-text-subtle);
        }

        .table-container {
            max-height: 400px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            position: sticky;
            top: 0;
            background: var(--color-bg-subtle);
            z-index: 10;
        }

        th {
            padding: 12px 15px;
            text-align: left;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-muted);
            border-bottom: 1px solid var(--color-border);
            border-left: 1px solid var(--color-border);
            cursor: pointer;
            user-select: none;
            font-family: var(--font-ui);
            white-space: nowrap;
        }

        th:first-child {
            border-left: none;
        }

        th:hover {
            color: var(--color-text);
        }

        th.sorted-asc::after,
        th.sorted-desc::after {
            display: inline;
            margin-left: 4px;
        }
        th.sorted-asc::after { content: '▲'; }
        th.sorted-desc::after { content: '▼'; }

        td {
            padding: 12px 15px;
            font-size: 0.9em;
            border-bottom: 1px solid var(--color-border);
            border-left: 1px solid var(--color-border);
        }

        td:first-child {
            border-left: none;
        }

        tr:hover {
            background: var(--color-bg-subtle);
            cursor: pointer;
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.75em;
            font-weight: 600;
            font-family: var(--font-ui);
            white-space: nowrap;
        }

        .badge-death { background: #c0392b; color: #fff; }
        .badge-released { background: #27ae60; color: #fff; }
        .badge-banished { background: #d4a017; color: #fff; }
        .badge-other { background: #7f8c8d; color: #fff; }

        .badge-female { background: #9b59b6; color: #fff; }
        .badge-male { background: #3498db; color: #fff; }

        .badge-paradox {
            background: var(--color-accent);
            color: #fff;
        }

        .econ-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .econ-comfortable { background: #27ae60; }
        .econ-middling { background: #3498db; }
        .econ-poor { background: #e67e22; }
        .econ-destitute { background: #c0392b; }

        /* Detail Panel */
        .detail-panel {
            position: fixed;
            right: -520px;
            top: 0;
            width: 520px;
            height: 100vh;
            background: var(--color-bg-card);
            border-left: 1px solid var(--color-border);
            box-shadow: -5px 0 30px rgba(0,0,0,0.15);
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }

        .detail-panel.open {
            right: 0;
        }

        .detail-header {
            padding: 25px;
            background: var(--color-bg-subtle);
            border-bottom: 1px solid var(--color-border);
        }

        .detail-header h2 {
            font-size: 1.4em;
            margin-bottom: 5px;
            color: var(--color-text);
        }

        .detail-header .meta {
            font-size: 0.9em;
            color: var(--color-text-muted);
        }

        .detail-close {
            position: absolute;
            right: 20px;
            top: 20px;
            background: none;
            border: none;
            color: var(--color-text-muted);
            font-size: 1.5em;
            cursor: pointer;
        }

        .detail-close:hover {
            color: var(--color-text);
        }

        .detail-body {
            padding: 25px;
        }

        .detail-section {
            margin-bottom: 25px;
        }

        .detail-section h4 {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--color-accent);
            margin-bottom: 12px;
            font-family: var(--font-ui);
        }

        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .detail-item {
            background: var(--color-bg-subtle);
            padding: 10px 12px;
            border-radius: 5px;
        }

        .detail-item .label {
            font-size: 0.75em;
            color: var(--color-text-muted);
        }

        .detail-item .value {
            font-size: 1em;
            color: var(--color-text);
            font-weight: 500;
        }

        .detail-item.full-width {
            grid-column: 1 / -1;
        }

        .victim-card {
            padding: 12px 0 12px 12px;
            margin-bottom: 10px;
            border-left: 3px solid var(--color-accent);
        }

        .victim-card .victim-name {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--color-text);
        }

        .victim-card .victim-details {
            font-size: 0.85em;
            color: var(--color-text-muted);
        }

        .quote-card {
            padding: 15px 0 15px 15px;
            margin-bottom: 10px;
            border-left: 3px solid var(--color-banished);
            font-style: italic;
        }

        .quote-card .quote-text {
            margin-bottom: 8px;
            color: var(--color-text);
        }

        .quote-card .quote-source {
            font-size: 0.8em;
            color: var(--color-text-muted);
            font-style: normal;
        }

        /* Site Header */
        .site-header {
            background: var(--color-bg-card);
            border-bottom: 1px solid var(--color-border);
            padding: 1.5rem 2.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .site-header a {
            text-decoration: none;
            color: inherit;
        }

        .site-header .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            opacity: 0.9;
            transition: opacity 0.2s;
        }

        .site-header .logo:hover {
            opacity: 0.7;
        }

        .site-header .logo img {
            height: 2rem;
            width: auto;
        }

        .site-header nav {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .site-header nav a {
            font-size: 0.875rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            opacity: 0.6;
            transition: opacity 0.2s;
            font-family: var(--font-ui);
        }

        .site-header nav a:hover {
            opacity: 0.9;
        }

        /* Site Footer */
        .site-footer {
            background: var(--color-bg-card);
            border-top: 1px solid var(--color-border);
            padding: 2.5rem;
        }

        .site-footer .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .site-footer .footer-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .site-footer .footer-left img {
            height: 1.5rem;
            width: auto;
            opacity: 0.6;
        }

        .site-footer .footer-left span {
            font-size: 0.875rem;
            color: var(--color-text-muted);
        }

        .site-footer nav {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .site-footer nav a {
            font-size: 0.875rem;
            color: var(--color-text-muted);
            text-decoration: none;
            transition: color 0.2s;
        }

        .site-footer nav a:hover {
            color: var(--color-text);
        }

        /* Intro text styling */
        .intro-text {
            color: var(--color-text-muted);
            font-size: 1em;
            line-height: 1.7;
            margin-bottom: 24px;
            max-width: 75ch;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            .sidebar {
                display: none;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--color-bg-subtle);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--color-border-strong);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--color-text-subtle);
        }
    </style>
</head>
<body>
    <!-- Site Header -->
    <header class="site-header">
        <a href="/" class="logo">
            <img src="/logo-alpha.png" alt="daggerobelus" />
        </a>
        <nav>
            <a href="/">Projects</a>
            <a href="/about/">About</a>
            <a href="/method/">Methodology</a>
            <a href="/contact/">Contact</a>
        </nav>
    </header>

    <div class="dashboard">
        <header>
            <div class="header-content">
                <div>
                    <h1>The Healer's Trap</h1>
                    <p class="subtitle">Folk Medicine and Witch Accusations in Lorraine, 1580-1630</p>
                </div>
                <nav class="header-nav">
                    <a href="#section-healers">The Healers</a>
                    <a href="#section-trial">The Trial</a>
                    <a href="#section-outcomes">Outcomes</a>
                    <a href="#section-data">Data</a>
                </nav>
            </div>
        </header>

        <aside class="sidebar">
            <div class="filter-section">
                <h3>Healing Type</h3>
                <div class="filter-group" id="filter-healing-type">
                    <button class="filter-btn active" data-value="all">All</button>
                </div>
            </div>

            <div class="filter-section">
                <h3>Gender</h3>
                <div class="filter-group" id="filter-gender">
                    <button class="filter-btn active" data-value="all">All</button>
                    <button class="filter-btn" data-value="female">Female</button>
                    <button class="filter-btn" data-value="male">Male</button>
                </div>
            </div>

            <div class="filter-section">
                <h3>Economic Status</h3>
                <div class="filter-group" id="filter-economic">
                    <button class="filter-btn active" data-value="all">All</button>
                    <button class="filter-btn" data-value="destitute">Destitute</button>
                    <button class="filter-btn" data-value="poor">Poor</button>
                    <button class="filter-btn" data-value="middling">Middling+</button>
                </div>
            </div>

            <div class="filter-section">
                <h3>Outcome</h3>
                <div class="filter-group" id="filter-outcome">
                    <button class="filter-btn active" data-value="all">All</button>
                    <button class="filter-btn" data-value="death">Death</button>
                    <button class="filter-btn" data-value="released">Released</button>
                    <button class="filter-btn" data-value="banished">Banished</button>
                </div>
            </div>

            <div class="filter-section">
                <h3>Special</h3>
                <div class="filter-group" id="filter-special">
                    <button class="filter-btn" data-value="paradox">Paradox Cases Only</button>
                </div>
            </div>

            <div class="filter-section">
                <div class="stat-card-mini">
                    <div class="label">Showing</div>
                    <div class="value" id="showing-count">-</div>
                </div>
            </div>
        </aside>

        <main class="main-content">
            <h2 class="section-header section-anchor" id="section-healers" style="margin-top: 0;">Who Were the Healers?</h2>

            <div class="types-overview" id="types-overview">
                <!-- Populated by JS -->
            </div>

            <h2 class="section-header section-anchor" id="section-trial">The Trial</h2>

            <div class="trial-section">
                <p class="trial-intro" id="trial-intro">
                    <!-- Populated by JS -->
                </p>
                <div class="trial-stats" id="trial-stats">
                    <!-- Populated by JS -->
                </div>

                <div class="charts-section">
                    <div class="chart-card">
                        <h3>What They Were Accused Of</h3>
                        <div id="chart-accusations"></div>
                    </div>

                    <div class="chart-card">
                        <h3>How Cases Were Built</h3>
                        <div id="chart-case-building"></div>
                    </div>

                    <div class="chart-card">
                        <h3>What They Confessed To</h3>
                        <div id="chart-confessions"></div>
                    </div>

                </div>
            </div>

            <h2 class="section-header section-anchor" id="section-outcomes">What Happened to Them?</h2>

            <p class="intro-text" id="outcomes-intro">
                <!-- Populated by JS -->
            </p>

            <div class="active-filters" id="active-filters" style="display: none;">
                <!-- Populated by JS -->
            </div>

            <div class="chart-card outcomes-chart">
                <h3>Trial Outcomes</h3>
                <div id="chart-outcomes"></div>
            </div>

            <div class="stat-cards" id="stat-cards">
                <!-- Populated by JS -->
            </div>

            <div class="charts-section">
                <div class="chart-card">
                    <h3>Death Rate by Healing Type</h3>
                    <div id="chart-healing-type"></div>
                </div>

                <div class="chart-card">
                    <h3>Death Rate by Economic Status</h3>
                    <div id="chart-economic"></div>
                </div>

                <div class="chart-card">
                    <h3>Death Rate by Paradox Effect</h3>
                    <div id="chart-paradox"></div>
                </div>

                <div class="chart-card">
                    <h3>Death Rate by Gender</h3>
                    <div id="chart-gender"></div>
                </div>

                <div class="chart-card">
                    <h3>Death Rate by Torture</h3>
                    <div id="chart-torture-outcome"></div>
                </div>
            </div>

            <h2 class="section-header section-anchor" id="section-data">
                <span>All Healers</span>
                <input type="text" id="search-input" placeholder="Search by name...">
            </h2>

            <div class="table-section">
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th data-sort="name">Name</th>
                                <th data-sort="age" style="text-align: right;">Age</th>
                                <th data-sort="gender" style="width: 1px;">Sex</th>
                                <th data-sort="healing">Healing Type</th>
                                <th data-sort="economic">Status</th>
                                <th data-sort="outcome">Outcome</th>
                                <th data-sort="paradox">Paradox</th>
                            </tr>
                        </thead>
                        <tbody id="healer-table-body">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </main>
    </div>

    <div class="detail-panel" id="detail-panel">
        <button class="detail-close" id="detail-close">&times;</button>
        <div class="detail-header">
            <h2 id="detail-name">-</h2>
            <p class="meta" id="detail-meta">-</p>
        </div>
        <div class="detail-body" id="detail-body">
            <!-- Populated by JS -->
        </div>
    </div>

    <script>
        // Baseline statistics from full corpus (379 accused across 356 trials)
        const BASELINE = {
            overall: 77.0,
            byGender: {
                female: 76.4,
                male: 78.7
            },
            byEconomic: {
                comfortable: 44.4,
                middling: 76.6,
                poor: 78.7,
                destitute: 76.1
            },
            totalAccused: 379,
            totalTrials: 356
        };

        // Global state
        let data = null;
        let filteredData = [];
        let sortColumn = 'name';
        let sortDirection = 'asc';
        let featuredHealers = new Set(); // Track healers already featured in tooltips
        let filters = {
            healingType: 'all',
            gender: 'all',
            economic: 'all',
            outcome: 'all',
            paradox: false,
            search: ''
        };

        // Initialize
        async function init() {
            try {
                const response = await fetch('../outputs/healer_network.json');
                data = await response.json();
                console.log('Loaded', data.healers.length, 'healers');

                buildHealingTypeFilters();
                applyFilters();
                setupEventListeners();
                startQuoteRotation();
                window.addEventListener('resize', positionTooltips);
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        function buildHealingTypeFilters() {
            const types = new Set();
            data.healers.forEach(h => {
                h.healing_types.forEach(t => types.add(t));
            });

            const container = document.getElementById('filter-healing-type');
            // Sort alphabetically, but put "other" and "unspecified" at the end
            const sortedTypes = Array.from(types).sort((a, b) => {
                if (a === 'other' || a === 'unspecified') return 1;
                if (b === 'other' || b === 'unspecified') return -1;
                return a.localeCompare(b);
            });

            sortedTypes.forEach(type => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.dataset.value = type;
                btn.textContent = formatLabel(type);
                container.appendChild(btn);
            });
        }

        function formatLabel(str) {
            return str.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        // Featured quote state
        let featuredQuotes = [];
        let currentQuoteIndex = 0;

        function updateFeaturedQuote() {
            // Gather quotes organized by healer type
            const quotesByType = {};

            filteredData.forEach(h => {
                if (h.notable_quotes && h.notable_quotes.length > 0) {
                    const type = h.primary_healing_type;
                    if (!quotesByType[type]) quotesByType[type] = [];

                    h.notable_quotes.forEach(q => {
                        const text = q.english || q.french;
                        if (text && text.length > 30 && text.length < 300) {
                            quotesByType[type].push({
                                text: text,
                                context: q.context,
                                healer: h.name,
                                type: type,
                                outcome: h.outcome,
                                hasParadox: h.has_paradox,
                                // Score for ranking within type
                                score: (h.has_paradox ? 10 : 0) +
                                       (q.context && q.context.toLowerCase().includes('threat') ? 5 : 0) +
                                       (q.context && q.context.toLowerCase().includes('heal') ? 3 : 0)
                            });
                        }
                    });
                }
            });

            // Sort quotes within each type by score, then take best ones
            Object.keys(quotesByType).forEach(type => {
                quotesByType[type].sort((a, b) => b.score - a.score);
            });

            // Build final list by rotating through types to ensure representation
            featuredQuotes = [];
            const types = Object.keys(quotesByType).sort((a, b) => {
                // Put "other" and "unspecified" at end
                if (a === 'other' || a === 'unspecified') return 1;
                if (b === 'other' || b === 'unspecified') return -1;
                return a.localeCompare(b);
            });

            // Take up to 3 quotes from each type, interleaved
            const maxPerType = 3;
            for (let i = 0; i < maxPerType; i++) {
                types.forEach(type => {
                    if (quotesByType[type] && quotesByType[type][i]) {
                        featuredQuotes.push(quotesByType[type][i]);
                    }
                });
            }

            // Reset to first quote
            currentQuoteIndex = 0;
            renderFeaturedQuote();
        }

        function renderFeaturedQuote() {
            const container = document.getElementById('featured-quote');
            if (!container) return; // Element removed from page
            if (featuredQuotes.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            const quote = featuredQuotes[currentQuoteIndex];
            const typeLabel = quote.type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const typeColor = (typeInfo[quote.type] || typeInfo['other']).color;

            container.innerHTML = `
                <div class="featured-quote-text">${quote.text}</div>
                <div class="featured-quote-attribution">
                    <span class="healer-name healer-link" onclick="jumpToHealer('${quote.healer.replace(/'/g, "\\'")}')" title="Click to view healer details">— ${quote.healer}</span>
                    <span class="healer-type" style="border-left: 3px solid ${typeColor}; padding-left: 8px;">${typeLabel}</span>
                    ${quote.context ? `<span class="quote-context">${quote.context}</span>` : ''}
                </div>
                <div class="featured-quote-nav">
                    <button onclick="pauseQuoteRotation(); prevQuote()" title="Previous quote">‹</button>
                    <button onclick="pauseQuoteRotation(); nextQuote()" title="Next quote">›</button>
                </div>
            `;
        }

        function nextQuote() {
            if (featuredQuotes.length > 0) {
                currentQuoteIndex = (currentQuoteIndex + 1) % featuredQuotes.length;
                renderFeaturedQuote();
            }
        }

        function prevQuote() {
            if (featuredQuotes.length > 0) {
                currentQuoteIndex = (currentQuoteIndex - 1 + featuredQuotes.length) % featuredQuotes.length;
                renderFeaturedQuote();
            }
        }

        // Auto-rotate quotes every 8 seconds
        let quoteRotationInterval = null;
        let quoteRotationPaused = false;

        function startQuoteRotation() {
            if (quoteRotationInterval) clearInterval(quoteRotationInterval);
            quoteRotationInterval = setInterval(() => {
                if (!quoteRotationPaused) {
                    nextQuote();
                }
            }, 8000);
        }

        function pauseQuoteRotation() {
            quoteRotationPaused = true;
            // Resume after 15 seconds of no interaction
            setTimeout(() => {
                quoteRotationPaused = false;
            }, 15000);
        }

        function applyFilters() {
            filteredData = data.healers.filter(h => {
                // Healing type filter
                if (filters.healingType !== 'all' && !h.healing_types.includes(filters.healingType)) {
                    return false;
                }

                // Gender filter
                if (filters.gender !== 'all' && h.gender !== filters.gender) {
                    return false;
                }

                // Economic filter
                if (filters.economic !== 'all') {
                    if (filters.economic === 'middling') {
                        if (!['middling', 'comfortable'].includes(h.economic_status)) return false;
                    } else if (h.economic_status !== filters.economic) {
                        return false;
                    }
                }

                // Outcome filter
                if (filters.outcome !== 'all' && h.outcome !== filters.outcome) {
                    return false;
                }

                // Paradox filter
                if (filters.paradox && !h.has_paradox) {
                    return false;
                }

                // Search filter
                if (filters.search && !h.name.toLowerCase().includes(filters.search.toLowerCase())) {
                    return false;
                }

                return true;
            });

            updateActiveFilters();
            updateFeaturedQuote();
            updateTypesOverview();
            updateStatCards();
            updateCharts();
            updateTable();
            document.getElementById('showing-count').textContent =
                `${filteredData.length} of ${data.healers.length}`;
        }

        function updateActiveFilters() {
            const activeFilters = [];

            // Check each filter
            if (filters.healingType !== 'all') {
                const label = filters.healingType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                activeFilters.push({
                    type: 'healingType',
                    label: 'Type',
                    value: label,
                    clear: () => { filters.healingType = 'all'; }
                });
            }

            if (filters.gender !== 'all') {
                activeFilters.push({
                    type: 'gender',
                    label: 'Gender',
                    value: filters.gender.charAt(0).toUpperCase() + filters.gender.slice(1),
                    clear: () => { filters.gender = 'all'; }
                });
            }

            if (filters.economic !== 'all') {
                const label = filters.economic === 'middling' ? 'Middling+' :
                              filters.economic.charAt(0).toUpperCase() + filters.economic.slice(1);
                activeFilters.push({
                    type: 'economic',
                    label: 'Status',
                    value: label,
                    clear: () => { filters.economic = 'all'; }
                });
            }

            if (filters.outcome !== 'all') {
                activeFilters.push({
                    type: 'outcome',
                    label: 'Outcome',
                    value: filters.outcome.charAt(0).toUpperCase() + filters.outcome.slice(1),
                    clear: () => { filters.outcome = 'all'; }
                });
            }

            if (filters.paradox) {
                activeFilters.push({
                    type: 'paradox',
                    label: '',
                    value: 'Paradox Cases Only',
                    clear: () => { filters.paradox = false; }
                });
            }

            if (filters.search) {
                activeFilters.push({
                    type: 'search',
                    label: 'Search',
                    value: `"${filters.search}"`,
                    clear: () => { filters.search = ''; document.getElementById('search-input').value = ''; }
                });
            }

            const container = document.getElementById('active-filters');
            const outcomesHeader = document.getElementById('section-outcomes');
            const trialHeader = document.getElementById('section-trial');

            if (activeFilters.length === 0) {
                container.style.display = 'none';
                outcomesHeader.innerHTML = 'What Happened to Them?';
                trialHeader.innerHTML = 'The Trial';
            } else {
                container.style.display = 'flex';

                // Build dynamic subject text
                let subjectText = '';
                if (filters.healingType !== 'all') {
                    const typeLabel = filters.healingType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    if (filters.healingType === 'midwifery') {
                        subjectText = '<span class="filter-context">Midwives</span>';
                    } else {
                        subjectText = `<span class="filter-context">${typeLabel} Healers</span>`;
                    }
                } else if (filters.gender !== 'all') {
                    subjectText = `<span class="filter-context">${filters.gender === 'female' ? 'Female' : 'Male'} Healers</span>`;
                } else {
                    subjectText = '<span class="filter-context">Filtered Healers</span>';
                }

                outcomesHeader.innerHTML = `What Happened to ${subjectText}?`;
                trialHeader.innerHTML = `The Trial: ${subjectText}`;

                // Build filter tags
                const tagsHtml = activeFilters.map((f, i) => `
                    <div class="filter-tag">
                        ${f.label ? `<span class="tag-label">${f.label}:</span>` : ''}
                        <span class="tag-value">${f.value}</span>
                        <button class="tag-remove" data-index="${i}">&times;</button>
                    </div>
                `).join('');

                container.innerHTML = `
                    <span class="active-filters-label">Filtered by:</span>
                    ${tagsHtml}
                    <button class="clear-all-filters">Clear All</button>
                `;

                // Add click handlers
                container.querySelectorAll('.tag-remove').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const index = parseInt(btn.dataset.index);
                        activeFilters[index].clear();
                        syncSidebarButtons();
                        applyFilters();
                    });
                });

                container.querySelector('.clear-all-filters').addEventListener('click', () => {
                    filters.healingType = 'all';
                    filters.gender = 'all';
                    filters.economic = 'all';
                    filters.outcome = 'all';
                    filters.paradox = false;
                    filters.search = '';
                    document.getElementById('search-input').value = '';
                    syncSidebarButtons();
                    applyFilters();
                });
            }
        }

        function syncSidebarButtons() {
            // Sync healing type buttons
            document.querySelectorAll('#filter-healing-type .filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === filters.healingType);
            });

            // Sync gender buttons
            document.querySelectorAll('#filter-gender .filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === filters.gender);
            });

            // Sync economic buttons
            document.querySelectorAll('#filter-economic .filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === filters.economic);
            });

            // Sync outcome buttons
            document.querySelectorAll('#filter-outcome .filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === filters.outcome);
            });

            // Sync paradox toggle
            document.querySelectorAll('#filter-special .filter-btn').forEach(btn => {
                btn.classList.toggle('active', filters.paradox);
            });
        }

        // Store type info globally for reuse
        const typeInfo = {
            'midwifery': {
                color: '#e74c3c',
                desc: 'Women who assisted with childbirth and infant care. When births went wrong, midwives were often blamed.',
                quote: '"Herbs that could make ill or heal as she chose."',
                narrative: 'Barbe "la grosse gorge" (1591) was a destitute widow who wandered between villages offering herbal cures and midwifery. Starving near Jametz, she met a figure who taught her these herbs. Those she healed with soups later accused her of poisoning them with mercury. Executed after confessing under torture.',
                exampleHealer: 'Barbe la grosse gorge'
            },
            'herbal_remedies': {
                color: '#27ae60',
                desc: 'Healers using plants, herbs, and natural preparations to treat illness. The line between medicine and magic was thin.',
                quote: '"You would have to bring the great devil to fix it."',
                narrative: 'Didelon l\'Huillier (1615) was a 70-year-old cattle keeper who cured sick cows by blowing pepper and ginger into their eyes. When animals later fell ill, the same villagers he\'d helped accused him. One witness, furious at his sick horse, spoke these words to Didelon. Executed.',
                exampleHealer: 'Didelon l\'Huillier'
            },
            'veterinary': {
                color: '#8e44ad',
                desc: 'Those who treated sick livestock. Animal deaths were economically devastating and often attributed to witchcraft.',
                quote: '"May God not let them live long enough to do such things."',
                narrative: 'Jean Colas Claude Martin (1593) was a carpenter-smith who healed sick animals using vegetables from his garden. Neighbors whose livestock recovered later blamed him when other animals died. Unlike most accused healers, he never confessed—even under pressure—and was released after 38 days. A rare survivor.',
                exampleHealer: 'Jean Colas Claude Martin'
            },
            'touch_healing': {
                color: '#f39c12',
                desc: 'Healing through laying on of hands, massage, or physical manipulation. Often associated with supernatural power.',
                quote: '"He threatened that he would repent."',
                narrative: 'Jean Anthoine dit Jean de Socourt (1607) was a shoemaker whose touch and black ointment cured some patients—then condemned him when others fell ill. Robert Thieriat, healed after sitting near Jean on a bench and receiving "something to eat," later testified against him at trial. Executed.',
                exampleHealer: 'Jean Anthoine dit Jean de Socourt'
            },
            'charms_amulets': {
                color: '#3498db',
                desc: 'Using spoken words, prayers, written charms, or blessed objects for healing. Blurred the boundary with religious practice.',
                quote: '"She remembered anger for seven years without showing it."',
                narrative: 'Mengeotte Lausson (1620) made healing soups from bread, salt, and ashes. Those who ate her remedies and recovered later accused her when family members fell ill years afterward. Executed.',
                exampleHealer: 'Mengeotte Lausson'
            },
            'other': {
                color: '#95a5a6',
                desc: 'Various folk healing practices not fitting other categories.',
                quote: '"She was a witch or there were none in the world."',
                narrative: 'Barbelline femme Didier Antoine (1604)—neighbors spoke these words about her. Her healing soup, laced with powder according to her confession, first cured Claude Anthoine, then allegedly made him ill. Executed.',
                exampleHealer: 'Barbelline femme Didier Antoine'
            },
            'unspecified': {
                color: '#bdc3c7',
                desc: 'Healing practice mentioned but specific type not recorded in trial documents.',
                quote: '"Defamed by common rumor of people who communicate among themselves."',
                narrative: 'Margueritte femme Didier Perisc (1628) was a 36-year-old domestic servant whose healing methods weren\'t recorded in detail. She testified that she did not know why she was defamed except by this common rumor. Executed.',
                exampleHealer: 'Margueritte femme Didier Perisc'
            },
            'divination': {
                color: '#1abc9c',
                desc: 'Practices involving prediction or finding lost objects, sometimes used alongside healing.',
                quote: '"Familiar spirits the size of flies, growing and shrinking."',
                narrative: 'Anthoine Grevillon (1625) was a 76-year-old traveling healer who confessed to owning these spirits, bought on a bridge in Lyon for five sols. He carried them in small boxes. He learned this from a soldier who carried one in a silver box during the siege of Ostend. Executed.',
                exampleHealer: 'Anthoine Grevillon'
            },
            'bone_setting': {
                color: '#7f8c8d',
                desc: 'Setting broken bones and treating injuries, a valued skill in rural communities.',
                quote: '"When I have healed your child you will say I am a witch and have me burned."',
                narrative: 'Nicolas Noel dit le Bragard (1593) was a 65-year-old former soldier and cobbler who practiced multiple healing arts. He confessed to making people ill with curses so they would consult him. When asked to heal a child, he cried these words. Executed.',
                exampleHealer: 'Nicolas Noel dit le Bragard'
            }
        };

        function updateTypesOverview() {
            // Use filteredData to respond to other filters, but get totals from all data for context
            const useFiltered = filters.gender !== 'all' || filters.economic !== 'all' ||
                               filters.outcome !== 'all' || filters.paradox || filters.search;

            const sourceData = useFiltered ? filteredData : data.healers;

            // Gather detailed stats for each type from filtered data
            const typeStats = {};
            sourceData.forEach(h => {
                h.healing_types.forEach(type => {
                    if (!typeStats[type]) {
                        typeStats[type] = {
                            healers: [],
                            deaths: 0,
                            female: 0,
                            male: 0,
                            paradox: 0
                        };
                    }
                    typeStats[type].healers.push(h);
                    if (h.outcome === 'death') typeStats[type].deaths++;
                    if (h.gender === 'female') typeStats[type].female++;
                    if (h.gender === 'male') typeStats[type].male++;
                    if (h.has_paradox) typeStats[type].paradox++;
                });
            });

            // Also get total counts from all data for reference
            const allTypeStats = {};
            data.healers.forEach(h => {
                h.healing_types.forEach(type => {
                    allTypeStats[type] = (allTypeStats[type] || 0) + 1;
                });
            });

            // Sort alphabetically, with "other" and "unspecified" at the end
            const sortedTypes = Object.keys(allTypeStats).sort((a, b) => {
                // Push "other" and "unspecified" to the end
                if (a === 'other' || a === 'unspecified') return 1;
                if (b === 'other' || b === 'unspecified') return -1;
                // Otherwise sort alphabetically
                return a.localeCompare(b);
            });

            const cardsHtml = sortedTypes.map(type => {
                const info = typeInfo[type] || typeInfo['other'];
                const label = type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const stats = typeStats[type] || { healers: [], deaths: 0, female: 0, male: 0, paradox: 0 };
                const count = stats.healers.length;
                const totalCount = allTypeStats[type];
                const paradoxPercent = count > 0 ? (stats.paradox / count * 100).toFixed(0) : 0;
                const femalePercent = count > 0 ? (stats.female / count * 100).toFixed(0) : 0;

                // Check if this type is currently selected
                const isSelected = filters.healingType === type;

                // Get 2 interesting example names
                const rankedHealers = [...stats.healers].sort((a, b) => {
                    let scoreA = 0, scoreB = 0;
                    if (a.has_paradox) scoreA += 10;
                    if (b.has_paradox) scoreB += 10;
                    if (a.notable_quotes && a.notable_quotes.length > 0) scoreA += 5;
                    if (b.notable_quotes && b.notable_quotes.length > 0) scoreB += 5;
                    scoreA += Math.min(a.victims?.length || 0, 3);
                    scoreB += Math.min(b.victims?.length || 0, 3);
                    return scoreB - scoreA;
                });

                // Show filtered vs total if filters are active
                const countDisplay = useFiltered && count !== totalCount
                    ? `${count}/${totalCount}`
                    : `${count}`;

                return `
                    <div class="type-card ${isSelected ? 'selected' : ''}" data-type="${type}">
                        ${info.narrative ? `
                            <div class="card-tooltip" data-healer="${info.exampleHealer || ''}">
                                ${info.quote ? `<div class="tooltip-quote">${info.quote}</div>` : ''}
                                <div class="tooltip-narrative">${info.narrative}</div>
                                ${info.exampleHealer ? `<div class="tooltip-citation">View trial record for ${info.exampleHealer} →</div>` : ''}
                            </div>
                        ` : ''}
                        <div class="type-card-header">
                            <span class="type-color" style="background: ${info.color}"></span>
                            <span class="type-name">${label}</span>
                            <span class="type-count">${countDisplay}</span>
                        </div>
                        <div class="type-card-desc">${info.desc}</div>
                        <div class="type-card-stats">
                            <div class="type-card-stat">
                                <div class="stat-value">${paradoxPercent}%</div>
                                <div class="stat-label">Paradox</div>
                            </div>
                            <div class="type-card-stat">
                                <div class="stat-value">${femalePercent}%</div>
                                <div class="stat-label">Female</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Calculate paradox stats for intro (always from full data)
            const paradoxCount = data.healers.filter(h => h.has_paradox).length;
            const paradoxPercent = (paradoxCount / data.healers.length * 100).toFixed(0);

            const container = document.getElementById('types-overview');
            container.innerHTML = `
                <p class="intro-text">
                    The Lorraine witch trial archive contains ${BASELINE.totalTrials} trials documenting ${BASELINE.totalAccused} accused individuals
                    between 1580-1630. Among them, ${data.healers.length} (${(data.healers.length / BASELINE.totalAccused * 100).toFixed(0)}%) were folk healers—people
                    who provided essential medical care in their communities. Yet their skills made them
                    uniquely vulnerable to witchcraft accusations. In ${paradoxPercent}% of cases, healers were accused of harming
                    the very people they had once treated—a pattern we call the "Healer's Paradox."
                </p>
                <div class="type-cards">
                    ${cardsHtml}
                </div>
            `;

            // Add click handlers to cards
            document.querySelectorAll('.type-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    // Don't trigger card filter if clicking on tooltip
                    if (e.target.closest('.card-tooltip')) return;

                    const type = card.dataset.type;

                    // Toggle selection
                    if (filters.healingType === type) {
                        filters.healingType = 'all';
                    } else {
                        filters.healingType = type;
                    }

                    // Update sidebar button state
                    document.querySelectorAll('#filter-healing-type .filter-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.value === filters.healingType);
                    });

                    applyFilters();
                });
            });

            // Add click handlers to tooltip citations
            document.querySelectorAll('.tooltip-citation').forEach(citation => {
                citation.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const tooltip = citation.closest('.card-tooltip');
                    const healerName = tooltip.dataset.healer;
                    if (healerName) {
                        jumpToHealer(healerName);
                    }
                });
            });

            positionTooltips();
        }

        // Position tooltips - flip alignment based on screen position (global function)
        function positionTooltips() {
            // Position type card tooltips
            document.querySelectorAll('.type-card').forEach(card => {
                const rect = card.getBoundingClientRect();
                const cardRight = rect.left + 280; // card position + tooltip width
                if (cardRight > window.innerWidth - 20) {
                    card.classList.add('tooltip-right');
                } else {
                    card.classList.remove('tooltip-right');
                }
            });

            // Position outcome tooltips
            document.querySelectorAll('.outcome-item').forEach(item => {
                const rect = item.getBoundingClientRect();
                const tooltipWidth = 280;
                const center = rect.left + rect.width / 2;

                // Reset classes
                item.classList.remove('tooltip-left', 'tooltip-right');

                // If centered tooltip would go off right edge
                if (center + tooltipWidth / 2 > window.innerWidth - 20) {
                    item.classList.add('tooltip-right');
                }
                // If centered tooltip would go off left edge
                else if (center - tooltipWidth / 2 < 20) {
                    item.classList.add('tooltip-left');
                }
            });
        }

        function jumpToHealer(healerName) {
            // Find the healer by name and show their detail panel
            const healer = data.healers.find(h =>
                h.name.toLowerCase() === healerName.toLowerCase()
            );
            if (healer) {
                showDetail(healer.id);
            }
        }

        function updateStatCards() {
            const total = filteredData.length;
            const deaths = filteredData.filter(h => h.outcome === 'death').length;
            const deathRate = total > 0 ? (deaths / total * 100) : 0;
            const paradoxCount = filteredData.filter(h => h.has_paradox).length;
            const avgAge = filteredData.filter(h => h.age).reduce((sum, h) => sum + h.age, 0) /
                           filteredData.filter(h => h.age).length || 0;

            // Compare to baseline
            const diff = deathRate - BASELINE.overall;
            const diffText = diff > 2 ? `${diff.toFixed(0)}pp higher than archive` :
                            diff < -2 ? `${Math.abs(diff).toFixed(0)}pp lower than archive` :
                            'similar to archive';
            const diffClass = diff > 2 ? 'worse' : diff < -2 ? 'better' : 'similar';

            const container = document.getElementById('stat-cards');
            container.innerHTML = `
                <div class="stat-card">
                    <div class="label">Total Healers</div>
                    <div class="value">${total}</div>
                    <div class="subtext">of ${data.healers.length} in dataset</div>
                    <div class="subtext baseline-compare">${(data.healers.length / BASELINE.totalAccused * 100).toFixed(0)}% of ${BASELINE.totalAccused} accused across entire archive</div>
                </div>
                <div class="stat-card highlight">
                    <div class="label">Healer Death Rate</div>
                    <div class="value">${deathRate.toFixed(0)}%</div>
                    <div class="subtext">${deaths} of ${total} executed</div>
                    <div class="subtext baseline-compare">vs ${BASELINE.overall.toFixed(0)}% across entire archive</div>
                </div>
            `;
        }

        function updateCharts() {
            // Clear featured healers tracker so we get fresh examples
            featuredHealers.clear();

            updateTrialSection();
            updateOutcomesChart();
            updateHealingTypeChart();
            updateEconomicChart();
            updateParadoxChart();
            updateGenderChart();
            updateTortureOutcomeChart();
            positionTooltips(); // Reposition tooltips after charts are updated
        }

        function updateTrialSection() {
            updateTrialStats();
            updateAccusationsChart();
            updateCaseBuildingChart();
            updateConfessionsChart();
        }

        function updateTrialStats() {
            const total = filteredData.length;
            const tortured = filteredData.filter(h => h.torture_used).length;
            const confessed = filteredData.filter(h => h.confessed).length;
            const confessedUnderTorture = filteredData.filter(h => h.confessed_under_torture).length;
            const retracted = filteredData.filter(h => h.retracted).length;

            // Calculate average witnesses
            const totalWitnesses = filteredData.reduce((sum, h) => sum + (h.witness_count || 0), 0);
            const avgWitnesses = total > 0 ? (totalWitnesses / total).toFixed(1) : 0;

            // Calculate average victims per healer
            const totalVictims = filteredData.reduce((sum, h) => sum + (h.victims?.length || 0), 0);
            const avgVictims = total > 0 ? (totalVictims / total).toFixed(1) : 0;

            const tortureRate = total > 0 ? (tortured / total * 100).toFixed(0) : 0;
            const confessionRate = total > 0 ? (confessed / total * 100).toFixed(0) : 0;

            // Paradox count for context
            const paradoxCount = filteredData.filter(h => h.has_paradox).length;

            // Update intro paragraph
            const introContainer = document.getElementById('trial-intro');
            introContainer.innerHTML = `
                Witch trials in Lorraine followed inquisitorial procedure: witnesses testified to the accused's reputation,
                specific harms they allegedly caused, and threats they may have made. For healers, their medical practice
                provided both the opportunity to harm and the reputation that made accusations stick.
                <span class="highlight">${paradoxCount}</span> of these ${total} healers were accused by people they
                had once treated—turning healing relationships into evidence of maleficium.
            `;

            const container = document.getElementById('trial-stats');
            container.innerHTML = `
                <div class="trial-stat highlight-red">
                    <div class="stat-value">${tortureRate}%</div>
                    <div class="stat-label">Tortured</div>
                    <div class="stat-context">${tortured} of ${total} healers</div>
                </div>
                <div class="trial-stat highlight-yellow">
                    <div class="stat-value">${confessionRate}%</div>
                    <div class="stat-label">Confessed</div>
                    <div class="stat-context">${confessedUnderTorture} under torture</div>
                </div>
                <div class="trial-stat">
                    <div class="stat-value">${avgWitnesses}</div>
                    <div class="stat-label">Avg Witnesses</div>
                    <div class="stat-context">per trial</div>
                </div>
                <div class="trial-stat">
                    <div class="stat-value">${avgVictims}</div>
                    <div class="stat-label">Avg Accusations</div>
                    <div class="stat-context">per healer</div>
                </div>
                <div class="trial-stat highlight-green">
                    <div class="stat-value">${retracted}</div>
                    <div class="stat-label">Retracted</div>
                    <div class="stat-context">confessions withdrawn</div>
                </div>
            `;
        }

        function updateAccusationsChart() {
            // Define known harm types first
            const knownHarmTypes = [
                'death', 'human_death', 'illness', 'human_illness',
                'injury', 'human_injury', 'animal_death', 'animal_illness',
                'crop_damage', 'property_damage'
            ];

            // Gather all harm types from victims, consolidating unknown types
            const harmCounts = {};
            filteredData.forEach(h => {
                (h.victims || []).forEach(v => {
                    let harmType = v.harm_type || 'other';
                    // Consolidate any unrecognized type into 'other'
                    if (!knownHarmTypes.includes(harmType)) {
                        harmType = 'other';
                    }
                    harmCounts[harmType] = (harmCounts[harmType] || 0) + 1;
                });
            });

            // Map harm types to categories and labels
            const harmCategories = {
                'death': { label: 'Caused Death', color: '#e74c3c', class: 'harm-death' },
                'human_death': { label: 'Caused Human Death', color: '#e74c3c', class: 'harm-death' },
                'illness': { label: 'Caused Illness', color: '#e67e22', class: 'harm-illness' },
                'human_illness': { label: 'Caused Human Illness', color: '#e67e22', class: 'harm-illness' },
                'injury': { label: 'Caused Injury', color: '#e67e22', class: 'harm-illness' },
                'human_injury': { label: 'Caused Human Injury', color: '#e67e22', class: 'harm-illness' },
                'animal_death': { label: 'Animal Death', color: '#8e44ad', class: 'harm-animal' },
                'animal_illness': { label: 'Animal Illness', color: '#8e44ad', class: 'harm-animal' },
                'crop_damage': { label: 'Crop Damage', color: '#3498db', class: 'harm-property' },
                'property_damage': { label: 'Property Damage', color: '#3498db', class: 'harm-property' },
                'other': { label: 'Other Harm', color: '#95a5a6', class: 'harm-other' }
            };

            // Sort by count descending
            const sortedHarms = Object.entries(harmCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8);

            const maxCount = sortedHarms.length > 0 ? sortedHarms[0][1] : 1;

            const html = sortedHarms.map(([harmType, count]) => {
                const info = harmCategories[harmType] || harmCategories['other'];
                const barWidth = (count / maxCount * 100).toFixed(0);
                return `
                    <div class="accusation-bar ${info.class}">
                        <span class="accusation-label">${info.label}</span>
                        <span class="accusation-count">${count}</span>
                        <div class="accusation-bar-fill">
                            <span style="width: ${barWidth}%; background: ${info.color}"></span>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('chart-accusations').innerHTML = html || '<p style="color: #666; font-size: 0.9em;">No accusation data available</p>';
        }

        function updateCaseBuildingChart() {
            // Analyze how cases were constructed
            const total = filteredData.length;

            // Witnesses with long reputation knowledge
            const longReputation = filteredData.filter(h => {
                return (h.witnesses || []).some(w => w.reputation_years && w.reputation_years > 10);
            }).length;

            // Cases with quarrels documented
            const withQuarrels = filteredData.filter(h => {
                return (h.witnesses || []).some(w => w.quarrel) ||
                       (h.victims || []).some(v => v.quarrel);
            }).length;

            // Witnesses who received threats
            const withThreats = filteredData.filter(h => {
                return (h.witnesses || []).some(w => w.threat_received);
            }).length;

            // Multiple witnesses
            const multipleWitnesses = filteredData.filter(h => h.witness_count >= 3).length;

            const html = `
                <div class="case-stat-row">
                    <span class="case-stat-label">Had prior quarrel documented</span>
                    <span class="case-stat-value">${total > 0 ? (withQuarrels / total * 100).toFixed(0) : 0}%</span>
                </div>
                <div class="case-stat-row">
                    <span class="case-stat-label">Witness claimed threat received</span>
                    <span class="case-stat-value">${total > 0 ? (withThreats / total * 100).toFixed(0) : 0}%</span>
                </div>
                <div class="case-stat-row">
                    <span class="case-stat-label">Long-standing reputation (10+ years)</span>
                    <span class="case-stat-value">${total > 0 ? (longReputation / total * 100).toFixed(0) : 0}%</span>
                </div>
                <div class="case-stat-row">
                    <span class="case-stat-label">3+ witnesses testified</span>
                    <span class="case-stat-value">${total > 0 ? (multipleWitnesses / total * 100).toFixed(0) : 0}%</span>
                </div>
            `;

            document.getElementById('chart-case-building').innerHTML = html;
        }

        function updateConfessionsChart() {
            const total = filteredData.length;
            const confessed = filteredData.filter(h => h.confessed).length;

            // Sabbat attendance
            const sabbatAttended = filteredData.filter(h => h.sabbat_attended).length;

            // Paradox confessions (confessed to harming people they healed)
            const paradoxConfessed = filteredData.filter(h => h.confessed && h.has_paradox).length;

            // Calculate rates - sabbat rate is among those who confessed
            const confessionRate = total > 0 ? (confessed / total * 100).toFixed(0) : 0;
            const sabbatRate = confessed > 0 ? (sabbatAttended / confessed * 100).toFixed(0) : 0;
            const paradoxRate = confessed > 0 ? (paradoxConfessed / confessed * 100).toFixed(0) : 0;

            const html = `
                <div class="confession-item">
                    <div class="confession-icon ${confessed > 0 ? 'active' : 'inactive'}">!</div>
                    <span class="confession-label">Confessed to witchcraft</span>
                    <span class="confession-rate">${confessionRate}%</span>
                    <span class="confession-count">${confessed} of ${total}</span>
                </div>
                <div class="confession-item">
                    <div class="confession-icon ${sabbatAttended > 0 ? 'active' : 'inactive'}">!</div>
                    <span class="confession-label">Admitted attending sabbat</span>
                    <span class="confession-rate">${sabbatRate}%</span>
                    <span class="confession-count">${sabbatAttended} of ${confessed} confessed</span>
                </div>
                <div class="confession-item">
                    <div class="confession-icon ${paradoxConfessed > 0 ? 'active' : 'inactive'}">!</div>
                    <span class="confession-label">Confessed to harming former patients</span>
                    <span class="confession-rate">${paradoxRate}%</span>
                    <span class="confession-count">${paradoxConfessed} of ${confessed} confessed</span>
                </div>
            `;

            document.getElementById('chart-confessions').innerHTML = html;
        }

        function updateTortureOutcomeChart() {
            // Show relationship between torture and death rate
            const tortured = filteredData.filter(h => h.torture_used);
            const notTortured = filteredData.filter(h => !h.torture_used);

            const groups = [
                {
                    key: 'tortured',
                    label: 'Tortured',
                    healers: tortured,
                    desc: 'Those subjected to torture during interrogation'
                },
                {
                    key: 'not-tortured',
                    label: 'Not Tortured',
                    healers: notTortured,
                    desc: 'Cases without documented use of torture'
                }
            ];

            const rows = groups
                .filter(g => g.healers.length > 0)
                .map(g => {
                    const deaths = g.healers.filter(h => h.outcome === 'death').length;
                    const rate = g.healers.length > 0 ? (deaths / g.healers.length * 100) : 0;

                    // Find best example
                    const bestHealer = findBestExampleHealer(g.healers, { excludeFeatured: true, markFeatured: true });
                    const quote = getBestQuote(bestHealer);
                    const narrative = bestHealer ? buildHealerNarrative(bestHealer, bestHealer.outcome) : null;
                    const healerName = bestHealer?.name || '';
                    const escapedName = healerName.replace(/'/g, "\\'");

                    const barClass = rate >= 95 ? 'bar-death-100' :
                                     rate >= 75 ? 'bar-death-high' :
                                     rate >= 65 ? 'bar-death-mid' : 'bar-death-low';

                    return `
                        <div class="chart-bar">
                            <span class="bar-label">${g.label}</span>
                            <div class="bar-track">
                                <div class="bar-fill ${barClass}" style="width: ${rate}%"></div>
                                <span class="bar-value">${rate.toFixed(0)}%</span>
                            </div>
                            <span class="bar-count">n=${g.healers.length}</span>
                            ${bestHealer ? `
                                <div class="bar-tooltip">
                                    ${quote ? `<div class="tooltip-quote">"${quote}"</div>` : ''}
                                    <div class="tooltip-narrative">${narrative || g.desc}</div>
                                    <div class="tooltip-citation" onclick="event.stopPropagation(); jumpToHealer('${escapedName}')">View trial record for ${healerName} →</div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');

            document.getElementById('chart-torture-outcome').innerHTML = rows;
        }

        // Find the best example healer from a list (one with quotes, paradox, interesting details)
        // Options: { excludeFeatured: true } to skip already-featured healers, { markFeatured: true } to add to tracker
        function findBestExampleHealer(healers, options = {}) {
            if (!healers || healers.length === 0) return null;

            const { excludeFeatured = false, markFeatured = false } = options;

            // Filter out already-featured healers if requested
            let candidates = healers;
            if (excludeFeatured) {
                candidates = healers.filter(h => !featuredHealers.has(h.id));
                // Fall back to all healers if everyone's been featured
                if (candidates.length === 0) candidates = healers;
            }

            // Score each healer by how interesting their record is
            const scored = candidates.map(h => {
                let score = 0;
                // Quotes are most valuable for narrative
                if (h.notable_quotes?.length > 0) score += 20;
                // Paradox cases are especially interesting
                if (h.has_paradox) score += 15;
                // Confession details add drama
                if (h.confessed && h.retracted) score += 10;
                if (h.confessed_under_torture) score += 5;
                // Having age/year adds context
                if (h.age) score += 3;
                if (h.trial_year) score += 2;
                // More healing types = more interesting
                score += (h.healing_types?.length || 0) * 2;
                return { healer: h, score };
            });

            // Sort by score descending
            scored.sort((a, b) => b.score - a.score);
            const chosen = scored[0]?.healer || null;

            // Mark as featured if requested
            if (chosen && markFeatured) {
                featuredHealers.add(chosen.id);
            }

            return chosen;
        }

        // Build a narrative from healer data
        function buildHealerNarrative(healer, outcome) {
            if (!healer) return null;

            const parts = [];

            // Name and basic info
            let intro = healer.name;
            if (healer.trial_year) intro += ` (${healer.trial_year})`;
            intro += ' was';
            if (healer.age) intro += ` a ${healer.age}-year-old`;
            if (healer.gender === 'male') intro += ' man';
            else if (healer.gender === 'female') intro += ' woman';

            // Healing practice
            const types = healer.healing_types?.filter(t => t !== 'unspecified' && t !== 'other') || [];
            if (types.length > 0) {
                const typeLabels = types.map(t => t.replace(/_/g, ' ')).slice(0, 2);
                intro += ` who practiced ${typeLabels.join(' and ')}`;
            }
            intro += '.';
            parts.push(intro);

            // Confession details
            if (healer.confessed) {
                if (healer.confessed_under_torture && healer.retracted) {
                    parts.push('Confessed under torture, then retracted.');
                } else if (healer.confessed_under_torture) {
                    parts.push('Confessed under torture.');
                } else if (healer.retracted) {
                    parts.push('Confessed, then retracted.');
                }
            } else if (healer.torture_used) {
                parts.push('Never confessed despite torture.');
            }

            // Paradox
            if (healer.has_paradox) {
                parts.push('A paradox case—accused by someone they had previously healed.');
            }

            // Outcome-specific
            if (outcome === 'death') {
                parts.push('Executed.');
            } else if (outcome === 'released') {
                parts.push('One of the rare cases to be released.');
            } else if (outcome === 'banished') {
                parts.push('Exiled rather than executed.');
            }

            return parts.join(' ');
        }

        // Get the best quote from a healer's record
        function getBestQuote(healer) {
            if (!healer?.notable_quotes?.length) return null;

            // Prefer quotes with English translations
            const withEnglish = healer.notable_quotes.filter(q => q.english);
            const quote = withEnglish[0] || healer.notable_quotes[0];

            return quote.english || quote.french || null;
        }

        function updateOutcomesChart() {
            // Group healers by outcome with detailed stats
            const outcomeData = {};
            filteredData.forEach(h => {
                const outcome = h.outcome || 'unknown';
                if (!outcomeData[outcome]) {
                    outcomeData[outcome] = {
                        healers: [],
                        byType: {},
                        female: 0,
                        male: 0,
                        paradox: 0
                    };
                }
                outcomeData[outcome].healers.push(h);
                if (h.gender === 'female') outcomeData[outcome].female++;
                if (h.gender === 'male') outcomeData[outcome].male++;
                if (h.has_paradox) outcomeData[outcome].paradox++;

                h.healing_types.forEach(type => {
                    outcomeData[outcome].byType[type] = (outcomeData[outcome].byType[type] || 0) + 1;
                });
            });

            const total = filteredData.length;

            // Define outcome order and basic labels
            const outcomeOrder = ['death', 'released', 'banished', 'fled', 'unknown'];
            const outcomeLabels = {
                'death': { label: 'Executed', desc: 'Condemned to death, typically by burning or hanging.' },
                'released': { label: 'Released', desc: 'Found innocent or charges dropped due to insufficient evidence.' },
                'banished': { label: 'Banished', desc: 'Exiled from the region, often after a lesser conviction.' },
                'fled': { label: 'Fled', desc: 'Escaped before trial concluded or execution.' },
                'unknown': { label: 'Unknown', desc: 'Outcome not recorded in surviving documents.' }
            };

            // Find max for scaling
            const counts = outcomeOrder.map(o => outcomeData[o]?.healers.length || 0);
            const maxCount = Math.max(...counts, 1);

            const barsHtml = outcomeOrder
                .filter(outcome => outcomeData[outcome]?.healers.length > 0)
                .map(outcome => {
                    const data = outcomeData[outcome];
                    const count = data.healers.length;
                    const percent = total > 0 ? (count / total * 100) : 0;
                    const barHeight = (count / maxCount) * 100;
                    const info = outcomeLabels[outcome];

                    // Find best example healer from the FILTERED data for this outcome
                    const bestHealer = findBestExampleHealer(data.healers, { excludeFeatured: true, markFeatured: true });
                    const dynamicQuote = getBestQuote(bestHealer);
                    const dynamicNarrative = buildHealerNarrative(bestHealer, outcome);

                    // Gender breakdown
                    const femalePercent = count > 0 ? (data.female / count * 100).toFixed(0) : 0;

                    // Build tooltip content
                    const hasContent = dynamicQuote || dynamicNarrative;
                    const healerName = bestHealer?.name || '';
                    const escapedName = healerName.replace(/'/g, "\\'");

                    return `
                        <div class="outcome-item">
                            <div class="outcome-tooltip" data-healer="${healerName}">
                                <h4>${info.label}</h4>
                                ${dynamicQuote ? `<div class="tooltip-quote">"${dynamicQuote}"</div>` : ''}
                                ${dynamicNarrative ? `<div class="tooltip-narrative">${dynamicNarrative}</div>` : `<p style="font-size: 0.85em; color: #888; margin-bottom: 10px;">${info.desc}</p>`}
                                ${healerName ? `<div class="tooltip-citation" onclick="event.stopPropagation(); jumpToHealer('${escapedName}')">View trial record for ${healerName} →</div>` : ''}
                            </div>
                            <div class="outcome-bar-container">
                                <div class="outcome-bar ${outcome}" style="height: ${barHeight}px;"></div>
                            </div>
                            <div class="outcome-value">${percent.toFixed(0)}%</div>
                            <div class="outcome-label">${info.label}</div>
                            <div class="outcome-count">${count} healers</div>
                        </div>
                    `;
                }).join('');

            // Update outcomes intro text
            const deathCount = outcomeData['death']?.healers.length || 0;
            const releasedCount = outcomeData['released']?.healers.length || 0;
            const deathRate = total > 0 ? (deathCount / total * 100).toFixed(0) : 0;

            document.getElementById('outcomes-intro').innerHTML = `
                Of the ${total} healers in this view, ${deathRate}% were executed—a rate comparable to
                the broader archive. Only ${releasedCount} were released, often after enduring torture
                without confession. The rest faced banishment, fled before sentencing, or their fates
                went unrecorded. Hover over each outcome to discover individual stories from the archive.
            `;

            document.getElementById('chart-outcomes').innerHTML = `
                <div class="outcomes-bars">
                    ${barsHtml}
                </div>
            `;
        }

        function createBarChart(container, data, options = {}) {
            const { showBaseline = false, baselineValue = null, baselineLegend = 'Entire archive' } = options;

            let html = data.map(d => {
                const barClass = d.rate >= 95 ? 'bar-death-100' :
                                 d.rate >= 75 ? 'bar-death-high' :
                                 d.rate >= 65 ? 'bar-death-mid' : 'bar-death-low';

                // Get baseline for this specific bar (if provided per-bar) or use global
                const baseline = d.baseline !== undefined ? d.baseline : baselineValue;
                const baselineMarker = baseline !== null ?
                    `<div class="baseline-marker" style="left: ${baseline}%" title="Archive: ${baseline.toFixed(0)}%"></div>` : '';

                return `
                    <div class="chart-bar">
                        <span class="bar-label">${d.label}</span>
                        <div class="bar-track">
                            ${baselineMarker}
                            <div class="bar-fill ${barClass}" style="width: ${d.rate}%"></div>
                            <span class="bar-value">${d.rate.toFixed(0)}%</span>
                        </div>
                        <span class="bar-count">n=${d.count}</span>
                    </div>
                `;
            }).join('');

            // Add baseline legend if showing baselines
            if (showBaseline && baselineValue !== null) {
                html += `
                    <div class="chart-baseline-legend">
                        <span class="baseline-legend-marker"></span>
                        <span>${baselineLegend} (${baselineValue.toFixed(0)}%)</span>
                    </div>
                `;
            } else if (showBaseline && data.some(d => d.baseline !== undefined)) {
                html += `
                    <div class="chart-baseline-legend">
                        <span class="baseline-legend-marker"></span>
                        <span>White marker = rate across entire archive</span>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function updateHealingTypeChart() {
            const stats = {};
            filteredData.forEach(h => {
                h.healing_types.forEach(type => {
                    if (!stats[type]) stats[type] = { total: 0, deaths: 0 };
                    stats[type].total++;
                    if (h.outcome === 'death') stats[type].deaths++;
                });
            });

            const chartData = Object.entries(stats)
                .map(([type, s]) => ({
                    label: formatLabel(type),
                    rate: s.total > 0 ? s.deaths / s.total * 100 : 0,
                    count: s.total
                }))
                .filter(d => d.count >= 3)
                .sort((a, b) => b.rate - a.rate);

            createBarChart(document.getElementById('chart-healing-type'), chartData);
        }

        function updateEconomicChart() {
            // Group healers by economic status (keeping healer objects for tooltip examples)
            const groups = {};
            filteredData.forEach(h => {
                const status = h.economic_status || 'unknown';
                if (!groups[status]) groups[status] = [];
                groups[status].push(h);
            });

            const order = ['comfortable', 'middling', 'poor', 'destitute'];
            const descriptions = {
                'comfortable': 'Those with property, trades, or stable income',
                'middling': 'Neither wealthy nor poor—the working middle',
                'poor': 'Living with limited means and resources',
                'destitute': 'The most vulnerable—widows, beggars, the dispossessed'
            };

            const rows = order
                .filter(status => groups[status]?.length > 0)
                .map(status => {
                    const healers = groups[status];
                    const deaths = healers.filter(h => h.outcome === 'death').length;
                    const rate = healers.length > 0 ? (deaths / healers.length * 100) : 0;
                    const baseline = BASELINE.byEconomic[status] || null;

                    // Find best example for this economic status
                    const bestHealer = findBestExampleHealer(healers, { excludeFeatured: true, markFeatured: true });
                    const quote = getBestQuote(bestHealer);
                    const narrative = bestHealer ? buildHealerNarrative(bestHealer, bestHealer.outcome) : null;
                    const healerName = bestHealer?.name || '';
                    const escapedName = healerName.replace(/'/g, "\\'");

                    const barClass = rate >= 95 ? 'bar-death-100' :
                                     rate >= 75 ? 'bar-death-high' :
                                     rate >= 65 ? 'bar-death-mid' : 'bar-death-low';

                    const baselineMarker = baseline !== null ?
                        `<div class="baseline-marker" style="left: ${baseline}%" title="Archive: ${baseline.toFixed(0)}%"></div>` : '';

                    return `
                        <div class="chart-bar">
                            <span class="bar-label">${formatLabel(status)}</span>
                            <div class="bar-track">
                                ${baselineMarker}
                                <div class="bar-fill ${barClass}" style="width: ${rate}%"></div>
                                <span class="bar-value">${rate.toFixed(0)}%</span>
                            </div>
                            <span class="bar-count">n=${healers.length}</span>
                            ${bestHealer ? `
                                <div class="bar-tooltip">
                                    ${quote ? `<div class="tooltip-quote">"${quote}"</div>` : ''}
                                    <div class="tooltip-narrative">${narrative || descriptions[status]}</div>
                                    <div class="tooltip-citation" onclick="event.stopPropagation(); jumpToHealer('${escapedName}')">View trial record for ${healerName} →</div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');

            document.getElementById('chart-economic').innerHTML = rows;
        }

        function updateParadoxChart() {
            const paradox = filteredData.filter(h => h.has_paradox);
            const nonParadox = filteredData.filter(h => !h.has_paradox);

            const groups = [
                {
                    key: 'paradox',
                    label: 'Paradox Cases',
                    healers: paradox,
                    desc: 'Accused by someone they had previously healed—the ultimate betrayal'
                },
                {
                    key: 'non-paradox',
                    label: 'Non-Paradox',
                    healers: nonParadox,
                    desc: 'Accused without documented prior healing relationship'
                }
            ];

            const rows = groups
                .filter(g => g.healers.length > 0)
                .map(g => {
                    const deaths = g.healers.filter(h => h.outcome === 'death').length;
                    const rate = g.healers.length > 0 ? (deaths / g.healers.length * 100) : 0;

                    // Find best example
                    const bestHealer = findBestExampleHealer(g.healers, { excludeFeatured: true, markFeatured: true });
                    const quote = getBestQuote(bestHealer);
                    const narrative = bestHealer ? buildHealerNarrative(bestHealer, bestHealer.outcome) : null;
                    const healerName = bestHealer?.name || '';
                    const escapedName = healerName.replace(/'/g, "\\'");

                    const barClass = rate >= 95 ? 'bar-death-100' :
                                     rate >= 75 ? 'bar-death-high' :
                                     rate >= 65 ? 'bar-death-mid' : 'bar-death-low';

                    return `
                        <div class="chart-bar">
                            <span class="bar-label">${g.label}</span>
                            <div class="bar-track">
                                <div class="bar-fill ${barClass}" style="width: ${rate}%"></div>
                                <span class="bar-value">${rate.toFixed(0)}%</span>
                            </div>
                            <span class="bar-count">n=${g.healers.length}</span>
                            ${bestHealer ? `
                                <div class="bar-tooltip">
                                    ${quote ? `<div class="tooltip-quote">"${quote}"</div>` : ''}
                                    <div class="tooltip-narrative">${narrative || g.desc}</div>
                                    <div class="tooltip-citation" onclick="event.stopPropagation(); jumpToHealer('${escapedName}')">View trial record for ${healerName} →</div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');

            document.getElementById('chart-paradox').innerHTML = rows;
        }

        function updateGenderChart() {
            const female = filteredData.filter(h => h.gender === 'female');
            const male = filteredData.filter(h => h.gender === 'male');

            const groups = [
                {
                    key: 'male',
                    label: 'Male',
                    healers: male,
                    baseline: BASELINE.byGender.male,
                    desc: 'Male healers were a minority but faced similar accusations'
                },
                {
                    key: 'female',
                    label: 'Female',
                    healers: female,
                    baseline: BASELINE.byGender.female,
                    desc: 'The vast majority of accused healers were women'
                }
            ];

            const rows = groups
                .filter(g => g.healers.length > 0)
                .map(g => {
                    const deaths = g.healers.filter(h => h.outcome === 'death').length;
                    const rate = g.healers.length > 0 ? (deaths / g.healers.length * 100) : 0;

                    // Find best example
                    const bestHealer = findBestExampleHealer(g.healers, { excludeFeatured: true, markFeatured: true });
                    const quote = getBestQuote(bestHealer);
                    const narrative = bestHealer ? buildHealerNarrative(bestHealer, bestHealer.outcome) : null;
                    const healerName = bestHealer?.name || '';
                    const escapedName = healerName.replace(/'/g, "\\'");

                    const barClass = rate >= 95 ? 'bar-death-100' :
                                     rate >= 75 ? 'bar-death-high' :
                                     rate >= 65 ? 'bar-death-mid' : 'bar-death-low';

                    const baselineMarker = g.baseline !== null ?
                        `<div class="baseline-marker" style="left: ${g.baseline}%" title="Archive: ${g.baseline.toFixed(0)}%"></div>` : '';

                    return `
                        <div class="chart-bar">
                            <span class="bar-label">${g.label}</span>
                            <div class="bar-track">
                                ${baselineMarker}
                                <div class="bar-fill ${barClass}" style="width: ${rate}%"></div>
                                <span class="bar-value">${rate.toFixed(0)}%</span>
                            </div>
                            <span class="bar-count">n=${g.healers.length}</span>
                            ${bestHealer ? `
                                <div class="bar-tooltip">
                                    ${quote ? `<div class="tooltip-quote">"${quote}"</div>` : ''}
                                    <div class="tooltip-narrative">${narrative || g.desc}</div>
                                    <div class="tooltip-citation" onclick="event.stopPropagation(); jumpToHealer('${escapedName}')">View trial record for ${healerName} →</div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');

            document.getElementById('chart-gender').innerHTML = rows;
        }

        function updateTable() {
            // Sort data
            const sorted = [...filteredData].sort((a, b) => {
                let aVal, bVal;

                switch(sortColumn) {
                    case 'name': aVal = a.name; bVal = b.name; break;
                    case 'age': aVal = a.age || 0; bVal = b.age || 0; break;
                    case 'gender': aVal = a.gender || ''; bVal = b.gender || ''; break;
                    case 'healing': aVal = a.primary_healing_type; bVal = b.primary_healing_type; break;
                    case 'economic': aVal = a.economic_status || ''; bVal = b.economic_status || ''; break;
                    case 'outcome': aVal = a.outcome || ''; bVal = b.outcome || ''; break;
                    case 'paradox': aVal = a.has_paradox ? 1 : 0; bVal = b.has_paradox ? 1 : 0; break;
                    default: aVal = a.name; bVal = b.name;
                }

                if (typeof aVal === 'string') {
                    return sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                }
                return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
            });

            const tbody = document.getElementById('healer-table-body');
            tbody.innerHTML = sorted.map(h => {
                const outcomeBadge = h.outcome === 'death' ? 'badge-death' :
                                     h.outcome === 'released' ? 'badge-released' :
                                     h.outcome === 'banished' ? 'badge-banished' : 'badge-other';
                const genderBadge = h.gender === 'female' ? 'badge-female' : 'badge-male';
                const econClass = `econ-${h.economic_status || 'unknown'}`;

                return `
                    <tr data-id="${h.id}">
                        <td style="max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${h.name}">${h.name}</td>
                        <td style="text-align: right;">${h.age || '-'}</td>
                        <td style="width: 1px; white-space: nowrap;"><span class="badge ${genderBadge}">${h.gender === 'female' ? 'F' : 'M'}</span></td>
                        <td>${formatLabel(h.primary_healing_type)}</td>
                        <td style="white-space: nowrap;"><span class="econ-indicator ${econClass}"></span>${formatLabel(h.economic_status || 'unknown')}</td>
                        <td><span class="badge ${outcomeBadge}">${formatLabel(h.outcome || 'unknown')}</span></td>
                        <td>${h.has_paradox ? '<span class="badge badge-paradox">Yes</span>' : '-'}</td>
                    </tr>
                `;
            }).join('');

            // Update sort indicators
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.sort === sortColumn) {
                    th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                }
            });
        }

        function showDetail(healerId) {
            const healer = data.healers.find(h => h.id === healerId);
            if (!healer) return;

            document.getElementById('detail-name').textContent = healer.name;
            document.getElementById('detail-meta').textContent =
                `${healer.trial_location || 'Unknown location'} | Trial ${healer.trial_id} | ${healer.trial_year || 'Date unknown'}`;

            let html = `
                <div class="detail-section">
                    <h4>Personal Details</h4>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <div class="label">Age</div>
                            <div class="value">${healer.age || 'Unknown'}${healer.age_approximate ? ' (approx)' : ''}</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Gender</div>
                            <div class="value">${formatLabel(healer.gender || 'unknown')}</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Economic Status</div>
                            <div class="value">${formatLabel(healer.economic_status || 'unknown')}</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Marital Status</div>
                            <div class="value">${formatLabel(healer.marital_status || 'unknown')}</div>
                        </div>
                        ${healer.occupation && healer.occupation.length ? `
                        <div class="detail-item full-width">
                            <div class="label">Occupation</div>
                            <div class="value">${healer.occupation.map(formatLabel).join(', ')}</div>
                        </div>
                        ` : ''}
                    </div>
                </div>

                <div class="detail-section">
                    <h4>Healing Practice</h4>
                    <div class="detail-grid">
                        <div class="detail-item full-width">
                            <div class="label">Healing Types</div>
                            <div class="value">${healer.healing_types.map(formatLabel).join(', ')}</div>
                        </div>
                    </div>
                </div>

                <div class="detail-section">
                    <h4>Trial Outcome</h4>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <div class="label">Outcome</div>
                            <div class="value" style="color: ${healer.outcome === 'death' ? '#e74c3c' : healer.outcome === 'released' ? '#27ae60' : '#f39c12'}">${formatLabel(healer.outcome || 'unknown')}</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Witnesses</div>
                            <div class="value">${healer.witness_count}</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Confessed</div>
                            <div class="value">${healer.confessed ? 'Yes' : 'No'}${healer.confessed_under_torture ? ' (under torture)' : ''}</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Tortured</div>
                            <div class="value">${healer.torture_used ? 'Yes' : 'No'}</div>
                        </div>
                    </div>
                </div>
            `;

            if (healer.has_paradox && healer.paradox_cases.length > 0) {
                html += `
                    <div class="detail-section">
                        <h4>Paradox Cases</h4>
                        <p style="color: #f1c40f; margin-bottom: 15px; font-size: 0.9em;">
                            This healer was accused of harming someone they had previously healed.
                        </p>
                `;
                healer.paradox_cases.forEach(p => {
                    html += `
                        <div class="victim-card">
                            <div class="victim-name">${p.person}</div>
                            <div class="victim-details">
                                <strong>Healed:</strong> ${p.healing_context || 'Context unknown'}<br>
                                <strong>Accused of:</strong> ${formatLabel(p.harm_type)} - ${p.harm_description || 'unspecified'}
                            </div>
                        </div>
                    `;
                });
                html += `</div>`;
            }

            if (healer.victims && healer.victims.length > 0) {
                html += `
                    <div class="detail-section">
                        <h4>Alleged Victims (${healer.victims.length})</h4>
                `;
                healer.victims.slice(0, 5).forEach(v => {
                    html += `
                        <div class="victim-card">
                            <div class="victim-name">${v.name}</div>
                            <div class="victim-details">
                                <strong>Harm:</strong> ${formatLabel(v.harm_type)}<br>
                                ${v.quarrel ? `<strong>Quarrel:</strong> ${v.quarrel}<br>` : ''}
                                ${v.method ? `<strong>Method:</strong> ${v.method}` : ''}
                            </div>
                        </div>
                    `;
                });
                if (healer.victims.length > 5) {
                    html += `<p style="color: #888; font-size: 0.9em;">+ ${healer.victims.length - 5} more victims</p>`;
                }
                html += `</div>`;
            }

            if (healer.notable_quotes && healer.notable_quotes.length > 0) {
                html += `
                    <div class="detail-section">
                        <h4>Notable Quotes</h4>
                `;
                healer.notable_quotes.slice(0, 3).forEach(q => {
                    html += `
                        <div class="quote-card">
                            <div class="quote-text">"${q.english || q.french}"</div>
                            <div class="quote-source">- ${q.speaker}, ${q.context}</div>
                        </div>
                    `;
                });
                html += `</div>`;
            }

            document.getElementById('detail-body').innerHTML = html;
            document.getElementById('detail-panel').classList.add('open');
        }

        function setupEventListeners() {
            // Filter buttons
            document.querySelectorAll('.filter-group').forEach(group => {
                group.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('filter-btn')) return;

                    const groupId = group.id;
                    const value = e.target.dataset.value;

                    // Handle special paradox toggle
                    if (groupId === 'filter-special') {
                        e.target.classList.toggle('active');
                        filters.paradox = e.target.classList.contains('active');
                    } else {
                        // Regular filter - exclusive selection
                        group.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');

                        if (groupId === 'filter-healing-type') filters.healingType = value;
                        if (groupId === 'filter-gender') filters.gender = value;
                        if (groupId === 'filter-economic') filters.economic = value;
                        if (groupId === 'filter-outcome') filters.outcome = value;
                    }

                    applyFilters();
                });
            });

            // Search
            document.getElementById('search-input').addEventListener('input', (e) => {
                filters.search = e.target.value;
                applyFilters();
            });

            // Table sorting
            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.addEventListener('click', () => {
                    const col = th.dataset.sort;
                    if (sortColumn === col) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = col;
                        sortDirection = 'asc';
                    }
                    updateTable();
                });
            });

            // Table row click
            document.getElementById('healer-table-body').addEventListener('click', (e) => {
                const row = e.target.closest('tr');
                if (row && row.dataset.id) {
                    showDetail(row.dataset.id);
                }
            });

            // Close detail panel
            document.getElementById('detail-close').addEventListener('click', () => {
                document.getElementById('detail-panel').classList.remove('open');
            });

            // Close on escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.getElementById('detail-panel').classList.remove('open');
                }
            });
        }

        // Start
        init();
    </script>

    <!-- Site Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-left">
                <img src="/logo-alpha.png" alt="" />
                <span>&copy; 2026</span>
            </div>
            <nav>
                <a href="/">Projects</a>
                <a href="/about/">About</a>
                <a href="/contact/">Contact</a>
            </nav>
        </div>
    </footer>
</body>
</html>
